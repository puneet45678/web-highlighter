{"version":3,"file":"content.bundle.js","mappings":"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","sources":["webpack://web-highlighter-extension/./src/content/highlight.js","webpack://web-highlighter-extension/./src/content/normalize.js","webpack://web-highlighter-extension/./src/content/selector.js","webpack://web-highlighter-extension/./src/content/restore.js","webpack://web-highlighter-extension/./src/content/content.js","webpack://web-highlighter-extension/./src/content/storage-temp.js"],"sourcesContent":["export function createHighlightSpan() {\n  const span = document.createElement(\"span\");\n  span.style.backgroundColor = \"yellow\";\n  span.style.cursor = \"pointer\";\n  span.className = \"web-highlighter-span\";\n  return span;\n}\n\nexport function applyHighlight(range) {\n  const span = createHighlightSpan();\n  console.log(span);\n  try {\n    range.surroundContents(span);\n  } catch (err) {\n    // fallback for complex selections\n    const fragment = range.extractContents();\n    span.appendChild(fragment);\n    range.insertNode(span);\n  }\n}\n","export function normalizeRangeToText(range) {\n  let startContainer = range.startContainer;\n  let startOffset = range.startOffset;\n  let endContainer = range.endContainer;\n  let endOffset = range.endOffset;\n\n  // Normalize start\n  while (startContainer.nodeType === Node.ELEMENT_NODE && startContainer.childNodes[startOffset]) {\n    startContainer = startContainer.childNodes[startOffset];\n    startOffset = 0;\n  }\n  \n  // If we ended on an element, find its first text node\n  if (startContainer.nodeType === Node.ELEMENT_NODE) {\n    const textNode = getFirstTextNode(startContainer);\n    if (textNode) {\n      startContainer = textNode;\n      startOffset = 0;\n    }\n  }\n\n  // Normalize end\n  while (endContainer.nodeType === Node.ELEMENT_NODE && endOffset > 0 && endContainer.childNodes[endOffset - 1]) {\n    endContainer = endContainer.childNodes[endOffset - 1];\n    endOffset = endContainer.nodeType === Node.TEXT_NODE ? endContainer.textContent.length : endContainer.childNodes.length;\n  }\n  \n  // If we ended on an element, find its last text node\n  if (endContainer.nodeType === Node.ELEMENT_NODE) {\n    const textNode = getLastTextNode(endContainer);\n    if (textNode) {\n      endContainer = textNode;\n      endOffset = textNode.textContent.length;\n    }\n  }\n\n  return { startContainer, startOffset, endContainer, endOffset };\n}\n\nfunction getFirstTextNode(node) {\n  if (node.nodeType === Node.TEXT_NODE) return node;\n  for (let child of node.childNodes) {\n    const textNode = getFirstTextNode(child);\n    if (textNode) return textNode;\n  }\n  return null;\n}\n\nfunction getLastTextNode(node) {\n  if (node.nodeType === Node.TEXT_NODE) return node;\n  for (let i = node.childNodes.length - 1; i >= 0; i--) {\n    const textNode = getLastTextNode(node.childNodes[i]);\n    if (textNode) return textNode;\n  }\n  return null;\n}","import { normalizeRangeToText } from \"./normalize\";\n\nexport function getXPath(node) {\n    if (node.nodeType === Node.TEXT_NODE) {\n        const parent = node.parentNode;\n        const textNodes = Array.from(parent.childNodes).filter(\n            n => n.nodeType === Node.TEXT_NODE\n        );\n        const index = textNodes.indexOf(node) + 1;\n        return getXPath(parent) + `/text()[${index}]`;\n    }\n\n    if (node === document.body) {\n        return \"/html/body\";\n    }\n\n    const index = Array.from(node.parentNode.children)\n        .filter(n => n.tagName === node.tagName)\n        .indexOf(node) + 1;\n\n    return getXPath(node.parentNode) + \"/\" + node.tagName.toLowerCase() + `[${index}]`;\n}\n\nexport function getContext(textNode, startOffset, endOffset, maxLength = 30) {\n  const text = textNode.textContent;\n\n  return {\n    prefix: text.substring(\n      Math.max(0, startOffset - maxLength),\n      startOffset\n    ),\n    suffix: text.substring(\n      endOffset,\n      Math.min(text.length, endOffset + maxLength)\n    )\n  };\n}\n\n\n\nexport function serializeRange(range) {\n  const normalized = normalizeRangeToText(range);\n\n  const startNode = normalized.startContainer;\n  const endNode = normalized.endContainer;\n\n  return {\n    text: range.toString(),\n    start: {\n      xpath: getXPath(startNode),\n      offset: normalized.startOffset\n    },\n    end: {\n      xpath: getXPath(endNode),\n      offset: normalized.endOffset\n    },\n    context: getContext(\n      startNode,\n      normalized.startOffset,\n      normalized.endOffset\n    )\n  };\n}","\nimport { applyHighlight } from \"./highlight.js\";\n\nexport function restoreHighlight(serialized) {\n  console.log(\"Trying XPath:\", serialized.start.xpath);\n\n  const startNode = getNodeByXPath(serialized.start.xpath);\n  const endNode = getNodeByXPath(serialized.end.xpath);\n\n  console.log(\"Resolved startNode:\", startNode);\n\n  if (!startNode || !endNode) {\n    return;\n  }\n\n  const range = document.createRange();\n  range.setStart(startNode, serialized.start.offset);\n  range.setEnd(endNode, serialized.end.offset);\n\n  applyHighlight(range);\n}\n\n\nexport function getNodeByXPath(xpath) {\n  const result = document.evaluate(\n    xpath,\n    document,\n    null,\n    XPathResult.FIRST_ORDERED_NODE_TYPE,\n    null\n  );\n  return result.singleNodeValue;\n}\n","import { applyHighlight } from \"./highlight.js\";\n\nimport { serializeRange } from \"./selector.js\";\nimport { restoreHighlight } from \"./restore.js\";\nimport { saveHighlightTemp, getHighlightsTemp } from \"./storage-temp.js\";\n\n\nconsole.log(\"[Highlighter] Restoring highlights\");\n\nconst highlights = getHighlightsTemp();\nconsole.log(\"Stored highlights:\", highlights);\n\nhighlights.forEach(restoreHighlight);\n\n\ndocument.addEventListener(\"mouseup\", () => {\n  debugger;\n  const selection = window.getSelection();\n  if (!selection || selection.isCollapsed) return;\n\n  const range = selection.getRangeAt(0);\n  const text = range.toString().trim();\n  if (!text) return;\n\n  applyHighlight(range);\n  const serialized = serializeRange(range);\n  saveHighlightTemp(serialized);\n  console.log(\"Serialized highlight:\", serialized);\n\n  selection.removeAllRanges();\n});\n\n\n","export function saveHighlightTemp(data){\n\n    const key = \"highlights\";\n    const existing = JSON.parse(localStorage.getItem(key) || \"[]\");\n    existing.push(data);\n    localStorage.setItem(key, JSON.stringify(existing));\n\n}\n\nexport function getHighlightsTemp() {\n  return JSON.parse(localStorage.getItem(\"highlights\") || \"[]\");\n}"],"names":["applyHighlight","range","span","document","createElement","style","backgroundColor","cursor","className","createHighlightSpan","console","log","surroundContents","err","fragment","extractContents","appendChild","insertNode","normalizeRangeToText","startContainer","startOffset","endContainer","endOffset","nodeType","Node","ELEMENT_NODE","childNodes","textNode","getFirstTextNode","TEXT_NODE","textContent","length","getLastTextNode","node","child","i","getXPath","parent","parentNode","index","Array","from","filter","n","indexOf","body","children","tagName","toLowerCase","getContext","maxLength","text","prefix","substring","Math","max","suffix","min","getNodeByXPath","xpath","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","highlights","JSON","parse","localStorage","getItem","forEach","serialized","start","startNode","endNode","end","createRange","setStart","offset","setEnd","addEventListener","selection","window","getSelection","isCollapsed","getRangeAt","toString","trim","normalized","context","serializeRange","data","key","existing","push","setItem","stringify","saveHighlightTemp","removeAllRanges"],"ignoreList":[],"sourceRoot":""}